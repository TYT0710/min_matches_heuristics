# The instances of the minimum number of matches problem are generated by solving the minimum utility cost problem.

from os import listdir
from lib.io_modules.readers import read_min_utility_test_case
from lib.problem_classes.transportation_model import Transportation_Model
from lib.instance_generation.transshipment_lp_solver import solve_transshipment_lp
from lib.io_modules.writers import write_mip_instance
from lib.io_modules.writers import write_bigM_parameters
# from lib.io_modules.writers import write_packing_instance

def solve_min_utility_cost():

	#test_sets=['furman_sahinidis','chen_grossmann_miller','grossmann_random']
	test_sets = ['large_scale']
	
	for test_set in test_sets:
		dat_files_path='data/original_instances/'+test_set+'/dat_files/'
		test_ids=listdir(dat_files_path) 
		
		for test_id in test_ids:
			if '~' not in test_id and test_id in ['large_scale4.dat', 'large_scale5.dat', 'large_scale6.dat']: 
				print(test_id)
				solver='cplex'
				test_id=test_id.replace('.dat','')
				
				min_utility_inst=read_min_utility_test_case(test_set, test_id)
				lp_inst=Transportation_Model(min_utility_inst)
				network = solve_transshipment_lp(test_set, test_id, solver, lp_inst, min_utility_inst)
				
				write_mip_instance(test_set, test_id, network)
				#write_bigM_parameters(test_set, test_id, network)
				
				# For the packing representation of the minimum number of matches problem.
				# write_packing_instance(test_set,test_id,packing) 
			
				## We do not create a packing instance for any of the subnetworks
				#if test_set in ['chen_grossmann_miller','grossmann_random']:
					#subnetworks=network.decomposition()
					#for s in subnetworks: 
						#write_mip_instance(test_set,test_id + '_subnetwork' + str(subnetworks.index(s)),s)
